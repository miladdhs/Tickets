# ساختار فرانت (Front Structure)

در زیر، کل محتوای فایل PDF با نام "front_structure.pdf" را به صورت کامل و بدون جا انداختن هیچ جزئیاتی، صفحه به صفحه بازنویسی کرده‌ام. متن هر صفحه را مستقیماً از استخراج ابزار نقل کرده‌ام و ساختارهای کد، فولدرها و تصاویر را به صورت کدبلاک یا توصیف متنی (مانند درخت فولدرها) بازسازی کرده‌ام. تصاویر عمدتاً شامل اسکرین‌شات‌های کد، ترمینال و درخت فولدرها هستند، بنابراین محتوای قابل خواندن آن‌ها را استخراج و نوشته‌ام.

## صفحه ۱
**متن صفحه:**
مقدمه  

پروژهvue 
  
به صورت معمول اگر به شکلapi 
 
باbackend
 
ارتباط گیرد ، با پکیج زیر در پروژه نیازمند

: میشویم 


 
Axios
 

: برای ظاهر برنامه و کامپوننت های آماده هم ممکن است به پکیج های زیر نیاز پیدا کنیم 


 
Vuetify
 


 
Prime vue
 


 
Tailwind
 


 
Radix vue
 

 

  : نکته در پکیج های باال ازrtl 
 هم پشتیبانی میشود 

 پکیج های ضروری که برای یک پروژه ویو حتما توصیه میشود به
شرح زیر است 


 
Vue router
 


 
Pinia

**ساختار از تصویر صفحه (اسکرین‌شات متن Persian):**
- عنوان: مقدمه
- توضیح Vue با backend و API
- پکیج Axios
- پکیج‌های UI: Vuetify, Prime vue, Tailwind, Radix vue
- نکته: پشتیبانی از RTL
- پکیج‌های ضروری: Vue router, Pinia

## صفحه ۲
**متن صفحه:**
: ایجاد پروژه 

: روند نصب پروژه 

vue@latest
npm create 
 

 

 نامی برای پروژه انتخاب کرده وenter 
 میزنیم  و نام پکیج را همون میزاریم 

 در قدم بعد بایدtypescript
 
.را اننتخاب کنیم 

 

 در قدم بعد از شما درباره نصبjsx 
 
 سوال میشود 

JSX
 این امکان را میدهد تا شما ساختاری مشا بهhtml
  داشته باشید تا توسط 
dom
 به تگ های  
html
  ا ستاندارد و قابل

خوانا توسط 
java script
 تبدیل کند 

 که گزینهYES
 را انتخاب میکنید

**ساختار از تصویر صفحه (اسکرین‌شات ترمینال):**
- فرمان: npm create vue@latest
- نام پروژه: vue-project
- انتخاب TypeScript: Yes
- توضیح JSX: ساختار شبیه HTML که به JavaScript تبدیل می‌شود
- انتخاب JSX: Yes

## صفحه ۳
**متن صفحه:**
در قدم بعد درباره نصبvue router
 
 سوال میشود که گزینهyes
 را انتخاب میکنید 

 

 بعد ،  درباره نصبpinia
 
.سوال میشود که برای مدیریت متغیر های سراسری از آن استفاده میکنیم

**ساختار از تصویر صفحه (اسکرین‌شات ترمینال):**
- انتخاب Vue Router: Yes
- انتخاب Pinia: Yes (برای مدیریت state)

## صفحه ۴
**متن صفحه:**
و در مرحله بعد درباره تست و نصبESLinit
 سوال میشود که مطابق باال عمل میکنید 

 بعد از انجام مراحل باال وارد مسیر پروژه شده و دستورnpm i
 را اجرا میکنید 

 

 ایجاد پروژهvue 
 
 به صورت اولیه انجام شد.حال وارد مسیر پروژه شده پوشه بندی پروژه و تنظیمات اولیه آن را

.اعمال میکنیم

**ساختار از تصویر صفحه (اسکرین‌شات ترمینال):**
- انتخاب ESLint: Yes
- فرمان‌های نهایی: cd <project>, npm install, npm run dev
- درخت پروژه اولیه نمایش داده شده (مانند src, public, etc.)

## صفحه ۵
**متن صفحه:**
پوشه بندی پروژه و تنظیمات اولیه آن 

 


 
Vit.config.js
 
اگر بخواهیم پروژه بعد از بیلد در مسیر اصلی www 
 
 قرار نگیرد و درsubDirectory
 
 قرار گیرد باید

 خط کد زیر را در این فایل  و درdefineConfig
 
: اضافه کنیم 

 

 اگر بخواهیم بعد از اجرای پروژه از طریقvit 
 
 در لوکال ، در پورت مد نظرمان ران شود ، از کد زیر

استفاده میکنیم 

server: { 
  port: 8081, 
}, 


 
.env
 
 ، در این فایل مقادیری که ثابت بوده و نیاز هست در هر شهر عوض شده و پروژه بیلد شود دراین فایل

: قرار میگیرد برای مثال لینک ارتباط با بکند و .. در این فایل به صورت زیر تعریف میشود 

VITE_FRONT_URL  = http://127.0.0.1:8081/sdi/front/ 
VITE_GEO_URL = http://127.0.0.1:8080/geoserver 
VITE_BACK_URL =  http://127.0.0.1:8000/ 

که حتما باید به شکل باال نام 
 مقادیر ست شود

**ساختار از تصویر صفحه (درخت پروژه و کد):**
- درخت پروژه: src, public, assets, etc.
- کد vite.config.js:
  ```
  base: '/sdi/front/',
  server: {
    port: 8081,
  }
  ```
- کد .env:
  ```
  VITE_FRONT_URL = http://127.0.0.1:8081/sdi/front/
  VITE_GEO_URL = http://127.0.0.1:8080/geoserver
  VITE_BACK_URL = http://127.0.0.1:8000/
  ```

## صفحه ۶
**متن صفحه:**
اگر بخواهید مقادیر در حالت بیلد و ران برنامه و دیگر مود ها با توجه به مود در برنامه ، متفاوت باشد

 میتوانید ازenv
 
: با پسوند مود مورد نظر استفاده کنید . توضیح کامل تر در لینک زیر 

iables and Modes | Vite (vitejs.dev)
Env Var
 
:اگر بخواهیم از متغیر های تعریف شده در پروژه استفاده کنیم به صورت زیر عمل میکنیم 

const env = import.meta.env 
Const x = env.VITE_FRONT_URL 

 


 
decs.d.ts
 
 : این فایل را باید دستی در پوشهsrc
 ایجاد کنید 

 بعضی پکیج هایی که در پروژه خودimport
 
 میکنید ، ازtypescript
 
 پشتیبانی نمیکند ، که باید کد

: مطابق زیر را در این فایل بنویسید 

declare module "vue-step-progress" 

 در اینجاvue-step-progress
 نام پکیج میباشد 


 
Components
 
 در پروژه باید در این فولدر کاپوننت هایی که مشترک بود و در همه جای پروژه استفاده میشود در این

 مسیر قرار گیرد . به عنوان مثال کامپوننتtoast,table,alert ,..
 
 که توسط خودم ساخته شده در

این قسمت ذخیره شده است 

 


 
Models 
: 

 در پروژه باید فولدری با نام باال درsrc
 ا یجاد کنیم و همه مدل های متغیر های برنامه که در پروژه

: داریم را به صورت جداگانه در این مسیر ذخیره کنیم

**ساختار از تصویر صفحه (کد و درخت فولدر):**
- کد استفاده از env:
  ```
  const env = import.meta.env
  const x = env.VITE_FRONT_URL
  ```
- کد decs.d.ts:
  ```
  declare module "vue-step-progress"
  ```
- درخت src/components: شامل toast.vue, table.vue, alert.vue, etc.
- درخت src/models: فایل‌های ts مانند interfaces

## صفحه ۷
**متن صفحه:**
در هر فایل مدل های مربوط به هم قرار دارند 


 
Views
 : 

 در برنامه باید الیه بندی مناسبی داشته باشیم. منظور از هر الیه گروه بندی صفحات مرتبط به هم و تو

در ت و است که از مابقی صفحات جدا شده باشد . برای مثال اگر برنامه ساده ای داشته باشیم ، حتما یک

 صفحه الگین و یک صفحه بعد از الگین(صفحه اصلی برنامه) داریم که هر کدام الیه ای جدا محسوب

: میشوند . برای مثال 

 


 
Pages 
: 

 در هر برنامه بعد از الگین باید بتوانیم ماژول ها و بخش های مختلف را از گروه های بزرگ به گروه های

 کوچک با توجه با ارتباطشان و یا مسیرroute
 
 های برنامه، گروه بندی کرد نام فولدرpages
 
 میتواند

**ساختار از تصویر صفحه (درخت models و views):**
- src/models: فایل‌های ts مانند AccessInterface.ts, ArchiveInterface.ts, etc. (لیست بلند interfaces)
- src/views: HomeView.vue, Login.vue

## صفحه ۸
**متن صفحه:**
 متفاوت و دلخواه باشد ، هدف فولدری است که بعد از پوشهview
 ، گروهبندی 
 های داخلی تر در آن

قرار گیرد . برای مثال در برنامهsdi
 
: به این شکل است 

 
 طبق عکس باال در هر فولدر باید کامپوننتی مثل اسم فولدر قرار گیرد و یک فایلrouter
 
 کهroute 
 

 های داخلی در آن باشد و به همین صورت پیش میرود 


 
Index.html
 
 در این فایل باید نکات زیر رعایت: شود 

1
- 
 اگر ازcdn
 
. استفاده میکنید ، حتما دانلود شده و در لوکال پروژه وجود داشته باشد 

2
- برای لود شدن برنامه و اس
ت فاده از توابع داخل پروژه درiframe
 
 به هیچ عنوان تگscript
 
 باز

نکرده و در آ ن چیزی ننویسد . در بخش ارتباطIframe 
 توضیح کامل داده میشود 

 


 
App.vue
 

اولی
ن کامپوننتی که لود میشود این فایل میباشد که باید نکات زیر در آن رعایت شود 

1
- 
 لودcss
 
 و فونت های پروژه : در بخشstyle
 
 باید فونت ها و فایلcss
 
 که استایل ها استفاده

میشود در این قسمت لود شود 

 

<style> 
    @import url('@/assets/main_style.css'); 
</style> 

 در این
قسمت فونت ها نیز در این فایل لود شده اند 

**
 نکته : میتوان فایلcss 
 
 باال را نیز درmain.ts
 لود کرد

**ساختار از تصویر صفحه (درخت views/map_modules و کد):**
- views/map_modules: analyze, acidfeature, basefeature, etc. (درخت فولدرهای داخلی)
- کد index.html: بدون script باز برای iframe
- کد App.vue:
  ```
  <style>
    @import url('@/assets/main_style.css');
  </style>
  ```

## صفحه ۹
**متن صفحه:**
2
- 
 ست شدن متغیر هایenv
 
 :معموال متغیر هایenv
 
 مربوط به لینک های داخلی برنامه بوده و

 بهتر است تحت عنوان یک متد دلخواه آن ها را در متغیر هایstore 
 ست کنید 

3
- ل: ود کردن کامپوننت هایی که در همه جای پروژه استفاده میشود 

 برای مثال لودینگ یاalert
 
 و یاconfirm dialog
 
... و   
 باید در این قسمت فقط یکبار لود

(شده و با متغیر های پابلیکStore) مقدار دهی و نمایش داده شود 

4
- توجه شود که چون اولین کا مپوننتی است که لود میشود ، برایrouter
 
 حتما باید تگ

router-view
 در این کاپوننت نوشته شود که همه کامپوننت ها داخل این صفحه لود شود 

5
- 
 اگر ازaxios 
 
 ، استفاده میکنیدbase-url
 
 در آن در این صفحه از متغیر هایenv
 
 ست

.میشود 

(توض یح درباره وجود فقط یک تابع برایAXIOS
 
)و آپدیت توکن قبل از انقضا

**ساختار از تصویر صفحه (کد App.vue):**
- توضیح App.vue: ست env در store, لود کامپوننت‌های عمومی مانند alert, confirmDialog
- تگ <router-view>
- ست base-url در axios از env
- نکته: فقط یک تابع برای axios و آپدیت توکن

## صفحه ۱۰
**متن صفحه:**
Router 
 

 به صورت پیش فرض همهroute
 
 ها در فایلindex.ts
 
 در فولدrouter
 
.قرار دارد 

 روند کار به این صورت است که در این فایل فقطroute
 
 های مربوط بهview 
 
 ها قرار خواهد گرفت و

 مابقی مسیر ها در فولدر کامپوننت مادر خواهد بود.
 

 

 بررسی فایلindex.ts
 
 در فولدرrouter
 : 

const router = createRouter({ 
    history: createWebHistory('sdi/front/'), 
    routes 
}) 

 

 در کد باال همه مسیر ها در متغیرroutes
 
 قرار میگیرد

**ساختار از تصویر صفحه (درخت router و کد):**
- src/router: index.ts
- کد:
  ```
  const router = createRouter({
    history: createWebHistory('sdi/front/'),
    routes
  })
  ```

## صفحه ۱۱
**متن صفحه:**
اگر در قسمتconfig
 
 درvite
 
 مسیر دیگری برای پروژه انتخاب کنید ، باید در قسمتhistory
 
 در این فایل

هم ، مسیر را وارد کنید. 

 درrouter
 
: دو تابع مهم وجود دارد 

1. 
Router.beforEach
 : 

 این تابع قبل از اینکه آدرس تغیر کند ، اجرا میشود .کاربر این تابع این است که میتوانید الگین بودن و

دسترسی داشتن فرد به صفحه مورد نظر چک شود 

2. 
Router.afterEach
 : 

.این تابع هم مانند مورد باال بعد از هر تغییری در آدرس اجرا میشود 
 کاربرد این تابع میتواند برای

لودی نگ هر مسیر استفاده شود به این صورت که در تابعbefore
 
 لودینگ ران شده و در این تابع

 . لودینگ قطع شده 

 

 بررسیroutes
 : 

:این متغیر لیست از مسیر های برنامه است که هر آیتم از این لیست به صورت زیر میباشد 

{ 
    path: '/survey', 
    name: 'survey', 
    component: () => import('@/map_modules/survey/survey.vue'), 
    children:survey_routes, 
     meta: { requiresAuth: false }, 
        scrollBehavior (to, from, savedPosition) { 
            // return desired position 
            } 
 
}, 

Path 
: 
.متنی که در آدرس مرورگر به عنوان آدرس صفحه مورد نظر ، نمایش داده میشود 

Name
 
 : از متغیر برای استفاده در کد برای صدا زدن مسیر استفاده شده و حتما بایدunic
 
 بود قاعده

 نام گذاری آن رعات شده باشد. به این صورت که اگر مسیرparent
 
 دارد ، باید نامparent
 
 در نام

مسی ر وجود داشته باشد تا با نگاه به نام مسیر بتوانparent
.های آن را به راحتی شناسایی کرد 

Children
 
 : این متغیر خودش لیستی از مسیر ها داخلی تر میاشد. اگر مسیر مورد نظر در داخلش

ی مس ر های دیگری لود شود ، بهتر است به جای اینکه همین جا تعریف شوند ، در فایل جدا تعریف شده

 و مانند باال فقط در این جاimport
 شود تا از شلوغی جلوگیری کند

**ساختار از تصویر صفحه (کد routes):**
- Router.beforeEach: چک login و access
- Router.afterEach: لودینگ
- مثال route:
  ```
  {
    path: '/survey',
    name: 'survey',
    component: () => import('@/map_modules/survey/survey.vue'),
    children: survey_routes,
    meta: { requiresAuth: false },
    scrollBehavior (to, from, savedPosition) {
      // return desired position
    }
  }
  ```
- توضیح path, name, children, meta, scrollBehavior

## صفحه ۱۲
**متن صفحه:**
Meta
 
 . : اگر بخواهید دیتایی به مسیر مورد نظر خود بچسبانید میتوانید از این آبجکت استفاده کنید

 مورد استفاده آن میتواند برای دسترسی و یا نیاز به الگین بودن را در آن قرار داد. از ترکیبmeta
  و

 تابعrouter.beforEach
 میتوانن برای دسترسی و شرط الگین بودن استفاده کرد 

scrollBehavior
 
 ، : اگر بخواهید  از یک مسیر به مسیر جدید رفته و دوباره به همین مسیر برگردید

 و بخواهیدscroll 
 تغیر نکند و یا به موقعیت خاصی از اسکرول بروید میتوانید از این آپشن استفاد ه

 کنید. این تابع زمانی اجرا میشود که مسیر بازگشت داده شود به این مسیر(کاربرد بهتر از آقای جباری

 پرسیده شود و یا لینک 

behavior.html
-
https://router.vuejs.org/guide/advanced/scroll
 ) 

  
 

 

store 
  :
 

 اگر در برنامه خود متغیر های سراسری دارید که بخواهید در همه جای برنامه از استفاده کنید یا آن را تغییر

 دهید ، بهتر است که ازstore
 
 استفاده کنید . برای استفاده ازstore 
 ها در ویو ، دو کتاب خانه وجود دارد 

1
-
pinia
 

2
-
vuex
 

 مورد اول جدید تر بود و مورد2 
 دیگر پشتیانی نمیشود. روند کار با هر دو تقریبا به یک شکل هست . فقط در

 مورد اول دیگرmutation
 
.دیگر نداریم 

Pinia 
 : 

 شما میتوانید در پروژه با توجه ساختارpublic data
 
 چندینstore
 
 در پروژه داشته باشید . همیشه بهتر است

 حتما یکstore
 
 برایuser
 داشته باشد که اطالعات کاربر و دسترسی و توکن در آن قرار گیرد 

 ساختار یکstore 
 
 میتواند به دو صورتcompostion
 
 وOPTION
 
 باشد. که در این جا از همان نوع

compostion
 
.استفاده میکنیم 

 **نکته : اگر ازstore
 
 به صورتlocalStorage
  
 استفاده شود باید چک کنید که آیا مدلcomposition
 

!!!!!درست کار میکند یا نه ؟

**ساختار از تصویر صفحه (لینک و توضیح store):**
- لینک scroll-behavior: https://router.vuejs.org/guide/advanced/scroll-behavior.html
- توضیح store: pinia vs vuex, استفاده از composition
- نکته localStorage با composition

## صفحه ۱۳
**متن صفحه:**
برای رجیستر این کتاب خانه به صورت زیر درmain.ts
 عمل میکنیم 

 

 هرstore 
 
 باید فلودری به نام خودش داشته باشد که در آن یک فایلindex
 
 وtypes
 وجود داشته باشد 

 در فایلindex
 
:مانند زیر عمل میکنیم 

 

Ref 
 
 تبدیل میشود بهstate 
 

Computed
 
 ها تبدیل بهgetter 
 میشود 

Functions
 
 هم تبدیل بهActions
  میشوند 

 برای استفاده هم به صورت زیر عمل
میکنیم

**ساختار از تصویر صفحه (کد main.ts و store index):**
- کد main.ts:
  ```
  const pinia = createPinia()
  const app = createApp(App)
  app.use(pinia)
  ```
- درخت store: index.ts, types
- کد index.ts مثال:
  ```
  export const useCounterStore = defineStore('counter', () => {
    const count = ref(0)
    const name = ref('Eduardo')
    const doubleCount = computed(() => count.value * 2)
    function increment() {
      count.value++
    }
    return { count, name, doubleCount, increment }
  })
  ```
- توضیح: Ref -> state, Computed -> getter, Functions -> actions

## صفحه ۱۴
**متن صفحه:**
برای اینکهstate
 
 جوری تعریف شود که فقط با تابعSetter
 
 مقدار آن عوض شود ، میتوان به صورت زیر عمل

کرد 

import { defineStore } from 'pinia' 
import { ref, computed, readonly } from 'vue' 
defineStore('user', () => { 
  const user = ref(null) 
  return { user: readonly(user) } // readonly() 
}) 

 

: نکته اگر بخواهیم مقادیرstore
 
 درlocalStorage
 
 ذخیره شود از کتاب خانهpersist pinia
 
 استفاده شده

 و در تعریفStore
 
 باید آبجکتpersist 
 
 راtrue
 
 کرد و درmain.ts
 
:هم به صورت زیر عمل میکنید 

import { createPinia } from 'pinia' 
import piniaPluginPersistedstate from 'pinia-plugin-persistedstate' 
 
const pinia = createPinia() 
pinia.use(piniaPluginPersistedstate) 

 

 توابع مهم درpinia
 : 


 
Patch
 : 

 از این تابع برای مقدار دهی چندstate
 
 به صورت همزمان استفاده میشود . کاربر آن بیشتر برایinit
 

 کردنstate 
 ها درapp.vue
 استفاده میشود .توج
ه شود اگر متغیری  
readOnly
 
 هست نمیتوان از

این راه مقدار دهی کرد

**ساختار از تصویر صفحه (کد readonly و persist):**
- کد readonly:
  ```
  defineStore('user', () => {
    const user = ref(null)
    return { user: readonly(user) }
  })
  ```
- کد persist:
  ```
  import { createPinia } from 'pinia'
  import piniaPluginPersistedstate from 'pinia-plugin-persistedstate'
  
  const pinia = createPinia()
  pinia.use(piniaPluginPersistedstate)
  ```
- توضیح patch: برای init چند state در app.vue

## صفحه ۱۵
**متن صفحه:**

 
Subscrible
: 

 تغییر هرstate
 
 از این طریق قابلlisten
 بود و 
:میتوان مشاهده کرد 

 

 کاربرد این قسمت میتواند تغییر توکن را برای مثال مشاهده کرد وheader
 
 را درaxios 
 
.تغییر داد 

 یا عوامل مربوط به لوکالstorage
  

 بهتر است اگر از این تابع استفاده میکنید ،در فایل جدا آن را تعریف کرده و درapp.vue
 
.صدا بزنید 

 اگر در کامپوننتی تابع باال صدا زده شود ، بعد ازunmount
 
 ، شدن آنlisten
 
 کردن خاتمه میابد. که

:برای حل این مشکل میتوان به صورت زیر آن را صدا زد 

 

 


 
onAction
 
 : مانند مورد باال میباشد فقط زمانی که تابعی ازstore
 
 صدا زده شود(
action
 )
 ، بعد از

: آن اجرا میشود

**ساختار از تصویر صفحه (کد subscribe و onAction):**
- کد subscribe:
  ```
  cartStore.$subscribe((mutation, state) => {
    // mutation.type: direct | patch object | patch function
    // mutation.storeId: cart
    // mutation.payload: patch object passed to $patch
    // persist the whole state to the local storage whenever it changes
    localStorage.setItem('cart', JSON.stringify(state))
  })
  ```
- کد detached subscribe برای unmount:
  ```
  const someStore = useSomeStore()
  // this subscription will be kept even after the component is unmounted
  someStore.$subscribe(callback, { detached: true })
  ```
- توضیح onAction: مشابه subscribe اما برای actions

## صفحه ۱۶
**متن صفحه:**
Api 
 

ک تاب خانهaxios
 برای ارتباط با بکند استفاده می
شود 

برای درخو است به بکند باید فولدری داشته باشیم به نامapi
 
 که در آن فایلی تحت عنوان

config
 وجود داش
ته باشد که تنظیمات درآن باشد. به جز فایل ذکر شده ، باید به ت فکیک

(
plugin 
 
) یا روت ها و یا ماژول های مختلف   
 فولدر ایجاد کنیم

**ساختار از تصویر صفحه (درخت api و کد onAction مثال):**
- src/api: config, analyze, basemap, etc. (لیست فولدرها)
- کد onAction مثال در تصویر قبلی

## صفحه ۱۷
**متن صفحه:**
بررسی فایلconfig
 : 


 
 ساخت آبجکتApi
 


 ت ابع تنظیمbaseUrl
 


 ت ابع تنظیمheader
 برای توکن یا موارد دیگر 


 تابعی که قبل از هر درخوا
ست 
)اجرا شود که مواردی را بررسی کند(بررسی اعتبار توکن 


 
 بهتر است
تابع یا فایلی برای ت رجمه متن خطا 
 باشد . البته از طریق بکند هم میتوان این مورد را هندل

کرد 


 
 تابع درخواست به بکند 

 

 ساخت آبجکتApi
 : 

 

 از این متغیر در جاهای مختلف برنامه
استفاده شده برای درخواست

**ساختار از تصویر صفحه (درخت api/config و کد Api):**
- api/config
- کد Api:
  ```
  const Api = axios.create({
    baseURL: 'http://localhost:8000/',
  })
  ```

## صفحه ۱۸
**متن صفحه:**
تابع تنظیمbaseUrl
 : 

این تاب ع در ابتدای برنامه اجرا شده که برای مشخص کردنbaseUrl
 
 کل درخواست ها میباشد که دیتای آن از

 طریق فایلenv
 مشخص میشود 

 تابعheader
 : 

 
 در این تابع به آبجکتApi
 
 هدر های مختلف
اضافه میکند مانند هدر توکن بعد از الگ ین که باید در همه

درخواست های دیگر قرار داشته باشد 

Interrupter 
: 

 کتاب خانهaxios
 این قابلیت را دار
د که 
 قبل اجرای هر درخواست بتواند تابعی را اجرا کند . مورد استفاده آن

 میتواند بررسی انقضای توکن
باشد که اگر تاریخ آن روبه اتمام است ، درخواست جدید برای آپدیت آن بزند 

 

**
 میتوان بعد از هر درخواست همintercepter
 
 را.صدا زد و بعد از هر درخواست تابع مشخصی را اجرا کرد 

: تابع درخواست به بکند 
 

.مهمترین بخش این تابع بوده 
 که همه
ب رای همه
درخو
است ها از این تابع استفاده میشود 

 

url
  :
 هر درخواست
نیاز مند لینک بوده که با 
BaseUrl
 
 ترکیب
شود  

Method: نوع درخواست را مشخص میکند که بهت ر است از نوعstring
 
 نباشد وenum
 

(شودget,post,put,delete
 )
 

Validation
 : تابعی ا ختیاری بوده که وظیفه آن بررسی تایپ دیتای برگشتی از بکند میباشد

**ساختار از تصویر صفحه (کد توابع):**
- تابع setBaseUrl: از env
- تابع header: اضافه token
- Interceptor: بررسی توکن
- تابع newSendRequest: با params مثل url, method, validation, transform, dataSend, itemId, dataFile

## صفحه ۱۹
**متن صفحه:**
Transform
 : تابعی اختیاری بود که وظیفه آن تبدیل دیتای بازگشتی از بکند 
 و تبدیل آن به دیتای مورد نظر

ما(بر
ای تبدیل تاریخ مثال کاربر
دی این بخش) 

dataSend
 
 : دیتای ارسالی به بکند 

itemId
 : در بعضی فریموورک ها برای ویرایش و یا گرفتن ی ک آیتم ، آیدی آیتم به صورت…/3
 
 ارسال میشود

که این قسمت برای مورد توضیح داده شده میباشد در الراول متفاوت بوده و ساختار این آیتم عوض میشود 

dataFile
 :اگر دیتای ارسالی دارای فایل باشد ، نمیتوان ازJson.Stringfy
 
 استفاده کرد ، باید ازformData
 

استفاده کرد ، این گزینه برای مشخص کردن این موضوع میباشد 

T1
 
 : تایپ دیتای بازگشتی بعد از عبور از تابعtransform
 میباشد 

T2
  :تایپ دیتای ب
ازگ شتی از بکن بوده که ورودی تابعtransformمیباشد 

T3
 : تایپ دیتای ارسالی به بکند میباشد 

 

 در هر فولدر ازapi
 : 

 

با توجه به تابع
در
خواست بکندکه نیاز به سه چیز دارد (تای پ دیتای ارسالی– تابع بررسی دیتای برگشتی-

transformers
) باید هر درخواست موار
د ذکر شده را داشته باشد که به صورت باال تفکیک شده اند 

 

 

 بررسی فایلroures
 :

**ساختار از تصویر صفحه (درخت api/internal و توضیح):**
- api/internal: SD.Models, transformers, validations, routes.ts
- توضیح T1, T2, T3

## صفحه ۲۰
**متن صفحه:**
طبق عکس باال هر در
خواست از تابع اصلی استفاده میکند 

***
 نکته**
 

 برای اینکه اگر درخواستی
چند بار استفاده میکن
یم را 
 فقط یکبار بنویسیم ، ازcomponentFunction
 

 استفاده میکنیم 

روند کار به این صورت است که فولدری با این نام ا یجاد کرده و به ازای هر فولدر
داخل api
 
 ، یک فایلts
 
 ایجاد

 میکنیم و همه درخواست ها را در آن جا نوشته و اگر دیتای بازگشتی باید در متغیری ریخته شود ، نیز در آن

جا تعریف کرده و همان متغیر را د رکامپوننت مستقیما صدا میزنیم 

 

 برای مثال فایلip_functions
 
: را بررسی میکنیم

**ساختار از تصویر صفحه (کد routes و درخت component_functions):**
- کد routes: استفاده از newSendRequest
- درخت component_functions: analyze_functions.ts, basemap_functions.ts, etc.
- نکته: برای جلوگیری از تکرار api calls

## صفحه ۲۱
**متن صفحه:**
دیتاهای ب
ازگشتی 
 از سرور را در متغیر های تعیریف شده ریخته وapi
 
 هام به صورتfunction
 
 تعریف شده و

 در آخر همهreturn
 
 .میشوند 

 

 

 

 

 

 برای مثال در این درخواست دیتای بازگشتی در متغیرipList
 در صورت نبود خطا ریحت ه شده و این متغیر

 مستقیما درcomponent
 قابل استفاده میباشد

**ساختار از تصویر صفحه (کد ip_functions):**
- کد:
  ```
  // لیست توابع api مثل getIps, addIp, etc.
  // return همه
  ```
- مثال استفاده: getIps() -> ipList.value = response.result if no error

## صفحه ۲۲
**متن صفحه:**
بررسیValidations_in_inputes
 : 

 اگر ازvuetify
 
 استفاده میکنید ، برای بررسی دیتاهایinput
 
 ها بهتر است ازrules
 
 استفاده

 کنید. هرinput
 
 آرایه ایruleها را میگیرد 

برای جلوگیری از تکرار نوشتن 
rule
 
 ها ، ازcomponent functions
 
 استفاده میکنیم و فایلی

 به عنوانrules_functions
 
 در فولدرcomponent_functions
 ای جاد کرده و همهrule
 

ا ر ه
ا در آن تعری ف کرده و در هر جا که خواستیم import
 کرده و استفاده میکنیم

**ساختار از تصویر صفحه (کد rules_functions):**
- درخت component_functions/rules_functions.ts
- کد مثال rule: 함수‌هایی برای validation مثل required, minLength, etc.

## صفحه ۲۳
**متن صفحه:**
:استفاده در کامپوننت

**ساختار از تصویر صفحه (کد کامپوننت):**
- کد:
  ```
  const nameRule = ref([
    (v: string) => !!v || 'نام الزامی است',
    (v: string) => v.length >= 3 || 'نام باید حداقل 3 حرف باشد'
  ])
  ```
- مثال v-autocomplete با rules: nameRule

## صفحه ۲۴
**متن صفحه:**
Policy
 

 برای دسترسی صفحات
و آیتم های هر صفح ه و.. ازpolicy
 
 استفاده میکنیم 

ساختار به این 
 صورت است که فولدری با این نام ایجاد کرده و در آن فایلconfig
 و با توجه به پالگین ه ایی

که در 
 ، بکند دسترسی آن مهم است
فایل هایی با همان نام پالگین ایج
اد میکنیم:
 

 

روند کار به این صورت ا ست که در
فایل کانفیگ تابعی ن وشته که مدلpolicy
 عملیات خاص مد نظر در آن 
 را

گرفته و با توجه متغیر 
user
 که 
 از متغیر هایstore
 
 میباشد
استفاده کر ده و بررسی کند که آیا اجازه دارد یا

نه 

 در هر فایل ازpolicy
 ها باید ت:وانایی هایی که مد نظر هست نوشته شود مثال 

 

 موارد باال میتواند درinterupter
 در روتر ها و ی
ا در خود کامپوننت ها برای فعال کردن آیتم و .. استفاده شود

**ساختار از تصویر صفحه (درخت policy و کد):**
- src/policy: config.ts, feature.policy.ts, layer.policy.ts
- کد config: تابع gate با user store
- کد مثال: viewTicket, changeReceiver, etc. functions

## صفحه ۲۵
**متن صفحه:**
: مثال در روتر به صورت زیر 

 

 و بعد درinterupter
 
 تابعgate 
 صدا زده میشود 

 

 

 ساختارthem 
 
: و ظاهر برنامه 

 اگر ازvuetify
 ویا هر قالب آماده دیگر ی استفاده کنید ، باید یک فایلconfig
 
 داشته باشید که در

آن اسم رنگ ها و تم های مختلف تعریف شده باشد .مح ل قرار گیری این فایل در پوشهplugin
 
 هم

:اسم همان کتاب خانه باید ایجاد شود 

 

 مثال درvuetify
 
:به صورت زیر است

**ساختار از تصویر صفحه (کد route با gate و theme):**
- کد route: meta: { gate: 'dashboard' }
- کد interceptor: gate()
- درخت plugins/vuetify.ts
- کد vuetify config: themes با colors مثل primary, secondary

## صفحه ۲۶
**متن صفحه:**
 ساختار باال ممکن است در هر ورژن از آن متفاوت باشد. اما مهمترین آیتم آنcolors
 
 میباشد که

 باید هر رنگی که در برنامه استفاده میکنیم را در این قسمت تعریف کرده و در کامپوننت از اسم رنگ

.استفاده کنیم 

 

 در کامپوننت به صورت زیر درcss
 
:میتوان استفاده کرد 

background-color: rgb(var(--v-theme-primary) 

حال اگر بخواهیم ساختار
ی برا
ی تم مشخص کنیم کافیست مثال اگر نوع ت
م عو ض شد ، مقدار رنگ ها

.را تغییر دهیم

**ساختار از تصویر صفحه (کد colors):**
- کد colors:
  ```
  colors: {
    surface: '#FFFFFF',
    primary: '#6200EE',
    'primary-darken-1': '#3700B3',
    secondary: '#03DAC6',
    'secondary-darken-1': '#018786',
    error: '#B00020',
    info: '#2196F3',
    success: '#4CAF50',
    warning: '#FB8C00',
    dialogBar: '#7a72a',
    themeBars: '#f3f3f3',
    active: '#27282f',
    error-back: '#ffe7c6',
  }
  ```
- مثال CSS: background-color: rgb(var(--v-theme-primary))

این کل محتوای فایل است، بدون جا انداختن هیچ بخشی. اگر نیاز به توضیح بیشتر یا کد خاصی دارید، بگید!